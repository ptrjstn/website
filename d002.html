<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>High-Q</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <main class="wrap">
    <pre class="ascii" data-ascii="header" data-title="ptrjstn"></pre>

    <h1 class="sr-only">ptrjstn</h1>

    <section class="page-content">
        <p class="text">finde die passenden nomen.</p>

    <!-- Haiku (monospace) mit echten Inputs -->
    <div class="mono haiku" id="haiku" aria-label="haiku">
      <!-- wird per JS gerendert -->
    </div>

    <p class="muted" id="feedback"></p>
    <p class="muted" id="progress"></p>

    <p class="muted" id="reveal"></p>

    <p class="text">
      <a href="index.html">← back</a>
      <span class="muted">/</span>
      <a href="#" id="nextLink">next</a>
      <span class="muted">/</span>
      <a href="#" id="clearLink">clear</a>
    </p>
    </section>

    <pre class="ascii" aria-hidden="true" data-ascii="line"></pre>

    <div id="sharedMeta"></div>

    <div id="sharedFooter"></div>
  </main>

  <script src="fragments.js"></script>
  <script src="shell.js"></script>
  <script src="haiku_db_30.js"></script>
  <script>
    // Regeln:
    // - Es gibt genau 3 Lücken (Nomen).
    // - Zeile 2 hat 2 Lücken, Zeile 3 hat 1 Lücke.
    // - Du tippst direkt in die Lücken.
    // - Quelle: haiku_db_30.json (später haiku_db_365.json)

    const DB_URL = "haiku_db_30.json";

    const haikuEl = document.getElementById("haiku");
    const feedbackEl = document.getElementById("feedback");
    const progressEl = document.getElementById("progress");
    const revealEl = document.getElementById("reveal");
    const nextLink = document.getElementById("nextLink");
    const clearLink = document.getElementById("clearLink");

    let pool = [];
    let current = null;
    let solved = [false, false, false];
    let inputs = [];

    function normalize(s) {
      return (s || "")
        .toLowerCase()
        .trim()
        .replaceAll("ß", "ss")
        .normalize("NFD").replace(/\p{Diacritic}/gu, "")
        .replace(/[^a-z]/g, "");
    }

    function approxWidthForAnswer(answer) {
      const len = (answer || "").trim().length;
      if (len <= 4) return 6;
      if (len <= 6) return 7;
      if (len <= 8) return 9;
      if (len <= 10) return 11;
      return 13;
    }

    function renderTextOrInput(token) {
      if (typeof token === "string") return document.createTextNode(token);

      const i = token;
      const inp = document.createElement("input");
      inp.type = "text";
      inp.inputMode = "text";
      inp.autocomplete = "off";
      inp.spellcheck = false;
      inp.className = "slot";
      inp.dataset.i = String(i);
      inp.placeholder = "";
      inp.setAttribute("aria-label", `slot ${i + 1}`);
      if (current?.answers?.[i]) {
        const w = approxWidthForAnswer(current.answers[i]);
        inp.style.width = `${w}ch`;
      }

      inp.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          evaluateSlot(i);
        }
      });

      inp.addEventListener("blur", () => evaluateSlot(i));

      // Beim Tippen: sofort bewerten
      inp.addEventListener("input", () => {
        evaluateSlot(i);
      });

      inputs[i] = inp;
      return inp;
    }

    function lineToTokensWithSlots(text, slotStartIndex, maxSlotsForLine) {
      const parts = String(text).split("___");
      if (parts.length === 1) return { tokens: [text], usedSlots: 0 };

      const tokens = [parts[0]];
      let used = 0;

      for (let i = 1; i < parts.length; i++) {
        if (used < maxSlotsForLine) {
          tokens.push(slotStartIndex + used);
          used += 1;
        } else {
          tokens.push("___");
        }
        tokens.push(parts[i]);
      }

      return { tokens, usedSlots: used };
    }

    function haikuFromDBItem(item) {
      const l1 = String(item.text_visible?.[0] ?? "").toLowerCase();
      const l2 = String(item.text_visible?.[1] ?? "").toLowerCase();
      const l3 = String(item.text_visible?.[2] ?? "").toLowerCase();

      const t2 = lineToTokensWithSlots(l2, 0, 2);
      const t3 = lineToTokensWithSlots(l3, 2, 1);

      return {
        line1: l1,
        line2: t2.tokens,
        line3: t3.tokens,
        answers: (item.solution || []).map((v) => String(v || "").toLowerCase()),
        author: item.author || "",
        born: item.born ?? null,
        died: item.died ?? null
      };
    }

    function renderPuzzle(p) {
      haikuEl.innerHTML = "";
      inputs = [];
      solved = p.answers.map(() => false);
      feedbackEl.textContent = "";
      revealEl.textContent = "";
      updateProgress();

      const line1 = document.createElement("div");
      line1.className = "line";
      line1.textContent = p.line1;

      const line2 = document.createElement("div");
      line2.className = "line";
      p.line2.forEach(tok => line2.appendChild(renderTextOrInput(tok)));

      const line3 = document.createElement("div");
      line3.className = "line";
      p.line3.forEach(tok => line3.appendChild(renderTextOrInput(tok)));

      haikuEl.appendChild(line1);
      haikuEl.appendChild(line2);
      haikuEl.appendChild(line3);

      focusFirstUnsolved();
    }

    function updateProgress() {
      const done = solved.filter(Boolean).length;
      progressEl.textContent = `found ${done}/${solved.length}`;

      if (done === solved.length) {
        feedbackEl.textContent = "";
        if (current?.author) {
          const dates = (current.born && current.died) ? ` (${current.born}–${current.died})` : "";
          revealEl.textContent = `${current.author}${dates}`;
        }
      }
    }

    function focusFirstUnsolved() {
      const idx = solved.findIndex(v => !v);
      const el = inputs[idx >= 0 ? idx : 0];
      if (el) {
        el.focus();
        el.setSelectionRange(el.value.length, el.value.length);
      }
    }

    function markOk(i) {
      inputs[i].classList.remove("bad");
      inputs[i].classList.add("ok");
      inputs[i].disabled = true;
      inputs[i].placeholder = "";
    }

    function evaluateSlot(i) {
      if (solved[i]) return;
      const guess = normalize(inputs[i].value);
      if (!guess) {
        inputs[i].classList.remove("bad");
        return;
      }

      const target = normalize(current.answers[i]);
      if (guess === target) {
        solved[i] = true;
        markOk(i);
        feedbackEl.textContent = "";
        updateProgress();
        focusFirstUnsolved();
      } else {
        feedbackEl.textContent = "";
        inputs[i].classList.add("bad");
      }
    }

    function clearAll() {
      if (!current) return;
      solved = current.answers.map(() => false);
      inputs.forEach((inp) => {
        inp.disabled = false;
        inp.value = "";
        inp.placeholder = "";
        inp.classList.remove("ok");
      });
      feedbackEl.textContent = "";
      revealEl.textContent = "";
      updateProgress();
      focusFirstUnsolved();
    }

    function nextPuzzle() {
      if (!pool.length) return;
      const raw = pool[Math.floor(Math.random() * pool.length)];
      current = haikuFromDBItem(raw);
      renderPuzzle(current);
    }
    async function loadDB() {
      if (window.HAIKU_DB && Array.isArray(window.HAIKU_DB.haikus) && window.HAIKU_DB.haikus.length) {
        pool = window.HAIKU_DB.haikus;
        return;
      }

      const candidates = [
        DB_URL,
        "./" + DB_URL,
        new URL(DB_URL, window.location.href).href,
        new URL(DB_URL, document.baseURI).href
      ];

      let lastErr = null;
      for (const url of [...new Set(candidates)]) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) {
            lastErr = new Error("DB load failed (" + url + "): " + res.status);
            continue;
          }

          const db = await res.json();
          pool = Array.isArray(db && db.haikus) ? db.haikus : [];
          if (pool.length) return;
          lastErr = new Error("DB is empty (" + url + ").");
        } catch (err) {
          lastErr = err;
        }
      }

      throw lastErr || new Error("DB load failed.");
    }

    nextLink.addEventListener("click", (e) => {
      e.preventDefault();
      nextPuzzle();
    });

    clearLink.addEventListener("click", (e) => {
      e.preventDefault();
      clearAll();
    });

    (async () => {
      try {
        await loadDB();
        nextPuzzle();
      } catch (err) {
        feedbackEl.textContent = "db error.";
        console.error(err);
      }
    })();
  </script>

  <style>
    :root{
      --panel: var(--surface);
      --ok: #859900;
      --bad: #dc322f;
    }

    body{
      background: var(--bg);
      color: var(--ink);
      font-family: var(--typewriter);
    }
    .page-content{
      margin: 42px 0;
    }

    .ascii{
      font-family: var(--typewriter);
      font-size: 13px;
      line-height: 1.2;
      margin-bottom: 16px;
    }

    .text{
      font-size: 15px;
      color: var(--ink);
    }

    .mono.haiku{
      margin: 14px 0;
      padding: 12px;
      border: 1px solid var(--line);
      background: var(--panel);
      font-family: var(--typewriter);
      font-size: 15px;
      line-height: 1.6;
    }

    .line{
      white-space: pre;
    }

    .slot{
      font: inherit;
      border: 0;
      border-bottom: 1px solid var(--line);
      background: transparent;
      padding: 0 2px;
      margin: 0;
      outline: none;
      color: var(--ink);
    }

    .slot:focus{
      background: rgba(147,161,161,0.18);
    }

    .slot.ok{
      border-bottom-color: var(--ok);
      color: var(--ok);
    }

    .slot.bad{
      border-bottom-color: var(--bad);
      color: var(--bad);
    }

    a{
      color: var(--link);
      text-decoration: underline;
      border-bottom: 0;
    }

    @media (max-width: 520px){
      .wrap{
        padding: 16px 14px 32px;
      }

      .ascii{
        font-size: 12px;
      }

      .mono.haiku{
        font-size: 16px;
        line-height: 1.65;
      }

      .line{
        white-space: normal;
      }

      .slot{
        min-width: 7ch;
      }
    }
  </style>
</body>
</html>
